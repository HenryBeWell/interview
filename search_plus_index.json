{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 此gitbookgitbookgitbook为Python面试整理，尽量包含以下内容: Python基础 Mysql数据库 Redis缓存 操作系统 网络知识 数据结构与算法 容器 搭建时用了 gitbook + github page + travis CI，全程参考使用 travis + gitbook + github pages 优雅地发布自己的书 · Issue #48 · riskers/blog，写的真的很好！ By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"container/":{"url":"container/","title":"容器","keywords":"","body":"容器 docker kubernetes By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"container/docker.html":{"url":"container/docker.html","title":"docker","keywords":"","body":"docker By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"container/kubernetes.html":{"url":"container/kubernetes.html","title":"kubernetes","keywords":"","body":"kubernetes By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/":{"url":"python/","title":"Python基础","keywords":"","body":"Python基础 面试常见问题 拷贝 闭包 装饰器 生成器与迭代器 垃圾回收机制 字典与集合 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/copy.html":{"url":"python/copy.html","title":"拷贝","keywords":"","body":"拷贝 在研究Python拷贝之前，先聊聊什么变量吧。在《流畅的python》中，有一个很形象的图解释了这一点： >>> a = [1, 2, 3] >>> b = a >>> a.append(4) >>> b [1, 2, 3, 4] 在Python中，我们可以将变量简单理解为，标注或者便利贴。 标识、相等性和别名 Lewis Carroll 是 Charles Lutwidge Dodgson 教授的笔名。Carroll 先生指的就是 Dodgson 教授，二者是同一个人。示例 1 用 Python 表达了这个概念。 示例 1 charles 和 lewis 指代同一个对象 >>> charles = {'name': 'Charles L. Dodgson', 'born': 1832} >>> lewis = charles ➊ >>> lewis is charles True >>> id(charles), id(lewis) ➋ (4300473992, 4300473992) >>> lewis['balance'] = 950 ➌ >>> charles {'name': 'Charles L. Dodgson', 'balance': 950, 'born': 1832} ❶ lewis 是 charles 的别名。 ❷ is 运算符和 id 函数确认了这一点。 ❸ 向 lewis 中添加一个元素相当于向 charles 中添加一个元素。 然而，假如有冒充者（姑且叫他 Alexander Pedachenko 博士）生于1832年，声称他是 Charles L. Dodgson。这个冒充者的证件可能一样，但是Pedachenko博士不是 Dodgson 教授。这种情况如图 2 所示。 图 2：charles 和 lewis 绑定同一个对象，alex 绑定另一个具有相同内容的对象 示例 4 实现并测试了图 2 中那个 alex 对象。 示例 4 alex 与 charles 比较的结果是相等，但 alex 不是charles >>> alex = {'name': 'Charles L. Dodgson', 'born': 1832, 'balance': 950} ➊ >>> alex == charles ➋ True >>> alex is not charles ➌ True ❶ alex 指代的对象与赋值给 charles 的对象内容一样。 ❷ 比较两个对象，结果相等，这是因为 dict 类的 _eq_ 方法就是这样实现的。 ❸ 但它们是不同的对象。这是 Python 说明标识不同的方式：a is not b。 示例 3 体现了别名。在那段代码中，lewis 和 charles 是别名，即两个变量绑定同一个对象。而 alex 不是 charles 的别名，因为二者绑定的是不同的对象。alex 和charles 绑定的对象具有相同的值（== 比较的就是值），但是它们的标识不同。 浅拷贝 创建新对象，其内容是原对象的引用 浅拷贝有三种形式： 切片操作，工厂函数，copy模块中的copy函数。 如： lst = [1,2,[3,4]] 切片操作：lst1 = lst[:]或者 lst1 = [each for each in lst] 工厂函数：lst1 = list(lst) copy函数：lst1 = copy.copy(lst) 浅拷贝之所以称为浅拷贝，是它仅仅只拷贝了一层，拷贝了最外围的对象本身，内部的元素都只是拷贝了一个引用而已，在lst中有一个嵌套的list[3,4]，如果我们修改了它，情况就不一样了。 深拷贝 和浅拷贝对应，深拷贝拷贝了对象的所有元素，包括多层嵌套的元素。深拷贝出来的对象是一个全新的对象，不再与原来的对象有任何关联。 所以改变原有被复制对象不会对已经复制出来的新对象产生影响。 只有一种形式，copy模块中的deepcopy函数 总结 对于可变对象深浅拷贝(外层改变元素) import copy l=[1,2,3,[4, 5]] l1=l #赋值 l2=copy.copy(l) #浅拷贝 l3=copy.deepcopy(l) #深拷贝 l.append(6) print(l) print(l1) print(l2) print(l3) 结果： [1, 2, 3, [4, 5], 6] #l添加一个元素6 [1, 2, 3, [4, 5], 6] #l1跟着添加一个元素6 [1, 2, 3, [4, 5]] #l2保持不变 [1, 2, 3, [4, 5]] #l3保持不变 对于可变对象深浅拷贝(内层改变元素) import copy l=[1,2,3,[4, 5]] l1=l #赋值 l2=copy.copy(l) #浅拷贝 l3=copy.deepcopy(l) #深拷贝 l[3].append(6) print(l) print(l1) print(l2) print(l3) 结果： [1, 2, 3, [4, 5, 6]] #l[3]添加一个元素6 [1, 2, 3, [4, 5, 6]] #l1跟着添加一个元素6 [1, 2, 3, [4, 5, 6]] #l2跟着添加一个元素6 [1, 2, 3, [4, 5]] #l3保持不变 外层添加元素时，浅拷贝不会随原列表变化而变化；内层添加元素时，浅拷贝才会变化。 无论原列表如何变化，深拷贝都保持不变。 赋值对象随着原列表一起变化。 参考 《流畅的Python》第八章 Python中的赋值(复制)、浅拷贝与深拷贝 - 知乎 (zhihu.com) By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/closure.html":{"url":"python/closure.html","title":"闭包","keywords":"","body":"闭包 在理解闭包前，先了解下什么函数嵌套。 函数嵌套 如果在一个函数内部定义了另一个函数，我们称外部的函数为外函数，内部的函数为内函数，这种行为，我们叫它，函数嵌套 示例代码： def out_func(): def inner_func1(): # 在内部定义函数1 print(\"the first inner func\") return def inner_func2(): # 在内部定义函数2 print(\"the second inner func\") return inner_func1() # 调用内部函数1 inner_func2() # 调用内部函数2 return out_func() # 调用外部函数 输出结果： the first inner func the second inner func 闭包 在一个外函数内定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包。 一般情况下，如果一个函数结束，函数内部所有的东西都会释放掉，还给内存，局部变量都会消失。但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。 示例： # 闭包函数的实例：outer()是外部函数，a和b都是外部函数的临时变量 def outer(a): b = 10 # inner()是内部函数 def inner(): # 在内部函数中用到了外部函数的临时变量 print(a+b) # 外部函数返回值是内部函数的引用 return inner # 调用外部函数，传入参数5。此时外函数两个临时变量a是5 b是10，并创建了内部函数，然后把内部函数的引用返回给了demo进行存储，外部函数结束的时候发现内部函数将会调用到自己的临时变量，这两个临时变量就不会释放，会绑定给这个内部函数 demo1 = outer(5) # demo存储了外部函数的返回值，也就是inner()函数的引用，这里相当于执行inner函数 demo1() # 15 demo2 = outer(7) demo2() # 17 说明： 外函数返回内函数的引用：在Python中一切都是对象，当我们进行变量赋值时(a=1)，实际上在内存中已经存储了值1，然后用a这个变量名存储1所在内存位置的引用。引用就好比C语言的指针，可以理解为地址。a只是变量名，a里面存储的是1的这个值所在的地址，就是a里面存储了数值1的引用。同理，当我们在Python中定义函数def demo():时，内存中会开辟一些空间，存下这个函数的代码、内部的局部变量等等。这个demo只不过是一个变量名，它里面存了这个函数所在位置的引用而已。我们还可以进行x=demo，y=demo，这样的操作就相当于把demo里存的内容赋值给x和y，这样x和y都指向了demo函数所在的引用，在这之后我们可以用x()或者y()来调用我们创建的demo()，调用的本质就是执行一个函数，x、y和demo三个变量名存了同一个函数的引用。对于上面的例子，在外部函数outer中最后返回inner，我们在调用外部函数demo=outer()时，outer返回了inner，inner是内部函数的引用，这个引用被存入了demo中，所以接下来我们再进行demo()时，相当于执行了inner函数。 在内部函数中想修改闭包变量(外部函数绑定给内部函数的局部变量)时：Python3中，可以使用nonlocal关键字声明一个变量，表示这个变量不是局部变量空间的变量，需要向上一层变量空间找这个变量；Python2中没有nonlocal这个关键字，可以把闭包变量改成可变类型数据进行修改，比如：列表, 字典等可变数据类型。 # 修改闭包变量实例 def outer(a): # outer是外部函数，a和b都是外部函数的临时变量 b = 10 # a和b都是闭包变量 c = [a] # 这里对应修改闭包变量的方法2 def inner(): # inner是内部函数 # 内函数中想修改闭包变量 nonlocal b # 方法1 nonlocal关键字声明 b += 1 c[0] += 1 # 方法2 把闭包变量修改成可变数据类型，比如：列表 print(f'after inner b: {b}, c:{c}') return b, c print(f'before inner b: {b}, c:{c}') return inner # 外部函数返回内部函数的引用 demo = outer(5) print(demo()) # before inner b: 10, c:[5] # after inner b: 11, c:[6] # (11, [6]) 注意：使用闭包的过程中，一旦外部函数被调用一次返回了内部函数的引用，虽然每次调用内部函数是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内部函数都在使用同一份闭包变量，如下代码： def outer(x): def inner(y): nonlocal x x += y return x return inner demo = outer(10) print(demo(1)) # 11 print(demo(3)) # 14 参考： 1: Python 嵌套函数和闭包 2: 深入浅出python闭包 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/decorator.html":{"url":"python/decorator.html","title":"装饰器","keywords":"","body":"装饰器 上一篇了解了什么是闭包，其实装饰器就是一个闭包，装饰器是闭包的一种应用。那么什么是装饰器呢，简言之，python装饰器就是用于在不影响原来函数功能的情况下拓展其额外功能的一种函数，这个函数的特殊之处在于它的输入输出都是函数。 一个比较经典的例子： import time from functools import wraps def timethis(func): ''' Decorator that reports the execution time. ''' @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper 其中@wraps(func) 注解是很重要的， 它能保留原始函数的元数据信息。 带参数的装饰器 我们用一个例子详细阐述下接受参数的处理过程。 假设你想写一个装饰器，给函数添加日志功能，同时允许用户指定日志的级别和其他的选项。 下面是这个装饰器的定义和使用示例： from functools import wraps import logging def logged(level, name=None, message=None): \"\"\" Add logging to a function. level is the logging level, name is the logger name, and message is the log message. If name and message aren't specified, they default to the function's module and name. \"\"\" def decorate(func): logname = name if name else func.__module__ log = logging.getLogger(logname) logmsg = message if message else func.__name__ @wraps(func) def wrapper(*args, **kwargs): log.log(level, logmsg) return func(*args, **kwargs) return wrapper return decorate # Example use @logged(logging.DEBUG) def add(x, y): return x + y @logged(logging.CRITICAL, 'example') def spam(): print('Spam!') 初看起来，这种实现看上去很复杂，但是核心思想很简单。 最外层的函数logged() 接受参数并将它们作用在内部的装饰器函数上面。 内层的函数decorate() 接受一个函数作为参数，然后在函数上面放置一个包装器。 这里的关键点是包装器是可以使用传递给 logged() 的参数的。 叠放装饰器 把 @d1 和 @d2 两个装饰器按顺序应用到 f 函数上，作用相当于 f = d1(d2(f))。 也就是说，下述代码： @d1 @d2 def f(): print('f') 等同于： def f(): print('f') f = d1(d2(f)) 参考 Python Cookbook 第九章 《流畅的Python》第七章 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/generator-iterator.html":{"url":"python/generator-iterator.html","title":"生成器与迭代器","keywords":"","body":"可迭代对象，迭代器和生成器 可迭代对象和迭代器 我们先了解下可迭代对象和迭代器之间的关系，在《流畅的Python》中，这样定义： 具体的 Iterable._iter_ 方法应该返回一个 Iterator 实例，具体的 Iterator 类必须实现 _next_ 方法，Iterator._iter_ 方法直接返回实例本身 。 abc.Iterator 类，摘自Lib/_collections_abc.py class Iterable(metaclass=ABCMeta): __slots__ = () @abstractmethod def __iter__(self): while False: yield None @classmethod def __subclasshook__(cls, C): if cls is Iterable: return _check_methods(C, \"__iter__\") return NotImplemented class Iterator(Iterable): __slots__ = () @abstractmethod def __next__(self): 'Return the next item from the iterator. When exhausted, raise StopIteration' raise StopIteration def __iter__(self): return self @classmethod def __subclasshook__(cls, C): if cls is Iterator: return _check_methods(C, '__iter__', '__next__') return NotImplemented 其中的魔术方法__subclasshook__作用在于，方便检查对象x是否是可迭代对象或者迭代器，即使对象 x 所属的类不是Iterator 类的真实子类或虚拟子类，也能这样检查。 生成器 生成器算是一种特殊的迭代器，可以记住上下文，接着上次返回的位置继续执行。生成器能做到迭代器能做的所有事，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法，当发生器终结时，还会自动抛出StopIteration异常。它的实现有以下两种方式： 函数内包含yield (I for I in range(10) # 使用列表推导式生成一个1到10的列表 l = [i for i in range(1,11)] print(l) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # 使用生成器表达式生成一个生成器（迭代器） l = (i for i in range(1,11)) print(l) # at 0x000002004151AA50> 一种优雅的实现读取大文件的方式 import functools def chunk_file_reader(fp, block_size): for chunk in iter(functools.partial(fp.read, block_size), bytes()): yield chunk def do_something(chunk): pass def main(file_path): with open(file_path, 'rb') as fp: for chunk in chunk_file_reader(fp, 1024 * 1024 * 1): do_something(chunk) 参考 《流畅的Python》第十四章 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/gc.html":{"url":"python/gc.html","title":"垃圾回收机制","keywords":"","body":"垃圾回收机制 先说结论：在Python中，主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。 引用计数 Python中，主要通过引用计数（Reference Counting）进行垃圾回收。 typedef struct_object { int ob_refcnt; struct_typeobject *ob_type; } PyObject; 在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。 以下情况是导致引用计数加一的情况: 对象被创建，例如a=2 对象被引用，b=a 对象被作为参数，传入到一个函数中 对象作为一个元素，存储在容器中 下面的情况则会导致引用计数减一: 对象别名被显示销毁 del 对象别名被赋予新的对象 一个对象离开他的作用域 对象所在的容器被销毁或者是从容器中删除对象 我们还可以通过sys包中的getrefcount()来获取一个名称所引用的对象当前的引用计数(注意，这里getrefcount()本身会使得引用计数加一) sys.getrefcount(a) 引用计数法有其明显的优点，如高效、实现逻辑简单、具备实时性，一旦一个对象的引用计数归零，内存就直接释放了。不用像其他机制等到特定时机。将垃圾回收随机分配到运行的阶段，处理回收内存的时间分摊到了平时，正常程序的运行比较平稳。但是，引用计数也存在着一些缺点，通常的缺点有： 逻辑简单，但实现有些麻烦。每个对象需要分配单独的空间来统计引用计数，这无形中加大的空间的负担，并且需要对引用计数进行维护，在维护的时候很容易会出错。 在一些场景下，可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间。 循环引用。这将是引用计数的致命伤，引用计数对此是无解的，因此必须要使用其它的垃圾回收算法对其进行补充。 也就是说，Python 的垃圾回收机制，很大一部分是为了处理可能产生的循环引用，是对引用计数的补充。 标记清除解决循环引用 Python采用了“标记-清除”(Mark and Sweep)算法，解决容器对象可能产生的循环引用问题。(注意，只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。而像数字，字符串这类简单类型不会出现循环引用。作为一种优化策略，对于只包含简单类型的元组也不在标记清除算法的考虑之列) 跟其名称一样，该算法在进行垃圾回收时分成了两步，分别是： A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达； B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。 如下图所示，在标记清除算法中，为了追踪容器对象，需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。python解释器(Cpython)维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象。在图中，这两个链表分别被命名为”Object to Scan”和”Unreachable”。图中例子是这么一个情况：link1,link2,link3组成了一个引用环，同时link1还被一个变量A(其实这里称为名称A更好)引用。link4自引用，也构成了一个引用环。从图中我们还可以看到，每一个节点除了有一个记录当前引用计数的变量ref_count还有一个gc_ref变量，这个gc_ref是ref_count的一个副本，所以初始值为ref_count的大小。 gc启动的时候，会逐个遍历”Object to Scan”链表中的容器对象，并且将当前对象所引用的所有对象的gc_ref减一。(扫描到link1的时候，由于link1引用了link2,所以会将link2的gc_ref减一，接着扫描link2,由于link2引用了link3,所以会将link3的gc_ref减一…..)像这样将”Objects to Scan”链表中的所有对象考察一遍之后，两个链表中的对象的ref_count和gc_ref的情况如下图所示。这一步操作就相当于解除了循环引用对引用计数的影响。 接着，gc会再次扫描所有的容器对象，如果对象的gc_ref值为0，那么这个对象就被标记为GC_TENTATIVELY_UNREACHABLE，并且被移至”Unreachable”链表中。下图中的link3和link4就是这样一种情况。 如果对象的gc_ref不为0，那么这个对象就会被标记为GC_REACHABLE。同时当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为GC_REACHABLE,这就是下图中link2和link3所碰到的情形。 除了将所有可达节点标记为GC_REACHABLE之外，如果该节点当前在”Unreachable”链表中的话，还需要将其移回到”Object to Scan”链表中，下图就是link3移回之后的情形。 第二次遍历的所有对象都遍历完成之后，存在于”Unreachable”链表中的对象就是真正需要被释放的对象。如上图所示，此时link4存在于Unreachable链表中，gc随即释放之。 上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。 分代回收 在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。 分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。 python gc给对象定义了三种世代(0,1,2),每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。 gc的扫描在什么时候会被触发呢?答案是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。 该阈值可以通过下面两个函数查看和调整: gc.get_threshold() # (threshold0, threshold1, threshold2). gc.set_threshold(threshold0[, threshold1[, threshold2]]) 下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10). 参考 Python垃圾回收机制！非常实用 - 知乎 (zhihu.com) By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"python/hash.html":{"url":"python/hash.html","title":"字典与集合","keywords":"","body":"字典与集合 在讨论pythonpythonpython中字典与集合背后的原理前，我们先了解下什么是hashable(可哈希化)。 可哈希化 在python官方文档中,对hashable定义如下： 一个对象的哈希值如果在其生命周期内绝不改变，就被称为 可哈希 （它需要具有 __hash__() 方法），并可以同其他对象进行比较（它需要具有 __eq__() 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。 可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。 大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 id()。来看下面的元组 tt、tl 和 tf： >>> tt = (1, 2, (30, 40)) >>> hash(tt) 8027212646858338501 >>> tl = (1, 2, [30, 40]) >>> hash(tl) Traceback (most recent call last): File \"\", line 1, in TypeError: unhashable type: 'list' >>> tf = (1, 2, frozenset([30, 40])) >>> hash(tf) -4118419923444501110 底层原理 python中的字典和集合的底层实现都是通过哈希表（散列表）。 散列表其实是一个稀疏数组（总是有空白元素的数组称为稀疏数组），在一般的数据结构教材中，散列表里的单元通常叫作表元（bucket）。在 dict 的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。 因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，Cpython会将原有的散列表自动扩容，复制到一个更大的空间里面。 如果要把一个对象放入散列表，那么首先要计算这个元素键的散列值。 散列值和相等性 python内置的 hash() 方法可以用于所有的内置类型对象。如果是自定义对象调用 hash() 的话，实际上运行的是自定义的 hash。如果两个对象在比较的时候是相等的，那它们的散列值必须相等，否则散列表就不能正常运行了。例如，如果 1 == 1.0 为真，那么 hash(1) == hash(1.0) 也必须为真，但其实这两个数字（整型 和浮点）的内部结构是完全不一样的。为了让散列值能够胜任散列表索引这一角色，它们必须在索引空间中尽量分散开来。这意味着在最理想的状况下，越是相似但不相等的对象，它们散列值的差别应该越大。 散列表算法 为了获取 my_dict[search_key] 背后的值： Python首先会调用hash(search_key) 来计算 search_key 的散列值，把这个值最低的几位数字当作偏移量，在散列表里查找表元（具体取几位，得看当前散列表的大小）。 若找到的表元是空的，则抛出 KeyError 异常。若不是空的，则表元里会有一对 found_key:found_value。 这时候 Python 会检验 search_key == found_key 是否为真，如 果它们相等的话，就会返回 found_value。 如果 search_key 和 found_key 不匹配的话，这种情况称为散列冲突（哈希碰撞）。发生这种情况是因为，散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分。为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下，把新得到的数字再当作索引来寻找表元。 若这次找到的表元是空的，则同样抛出 KeyError；若非空，或者键匹配，则返回这个值；或者又发现了散列冲突，则重复以上的步骤。 哈希查找时的逻辑图： 添加新元素和更新现有键值的操作几乎跟上面一样。只不过对于前者，在发现空表元的时候会放入一个新元素；对于后者，在找到相对应的表元后，原表里的值对象会被替换成新值。另外在插入新值时，Python 可能会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容。如果增加了散列表的大小，那散列值所占的位数和用作索引的位数都会随之增加，这样做的目的是为了减少发生散列冲突的概率。 这也从侧面说明，为何字典集合会是乱序。 解决哈希碰撞 假若输入数据长而经过哈希后的散列值短的话，可能存在不同的输入哈希后散列值相同的情况。因此在哈希表中常会出现哈希冲突这个现象。 解决哈希冲突的方法一般有：开放寻址法、链式地址法、建立公共溢出区和再哈希法。而开放寻址法又分为线性探测、再平方探测、伪随机探测等。 Python中字典在遇到哈希冲突时使用是开放寻址法。 参考 《流畅的Python》第三章 从CPython源码理解：Python字典如何解决哈希冲突？ - 知乎 (zhihu.com) By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"mysql/":{"url":"mysql/","title":"索引","keywords":"","body":"索引 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"mysql/engine.html":{"url":"mysql/engine.html","title":"引擎","keywords":"","body":"引擎 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"mysql/transaction.html":{"url":"mysql/transaction.html","title":"事务","keywords":"","body":"事务 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"redis/":{"url":"redis/","title":"Redis缓存","keywords":"","body":"Redis缓存 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"redis/data_type.html":{"url":"redis/data_type.html","title":"数据类型","keywords":"","body":"数据类型 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"redis/endurance.html":{"url":"redis/endurance.html","title":"持久化","keywords":"","body":"持久化 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"redis/cache.html":{"url":"redis/cache.html","title":"缓存","keywords":"","body":"缓存 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"redis/Endurance.html":{"url":"redis/Endurance.html","title":"一致性","keywords":"","body":"一致性 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:27 "},"os/":{"url":"os/","title":"操作系统","keywords":"","body":"操作系统 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"os/Concurrent.html":{"url":"os/Concurrent.html","title":"进程|线程|协程","keywords":"","body":"进程|线程|协程 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"os/linux.html":{"url":"os/linux.html","title":"Linux","keywords":"","body":"Linux By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"network/":{"url":"network/","title":"网络知识","keywords":"","body":"网络知识 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"network/osi.html":{"url":"network/osi.html","title":"OSI七层模型","keywords":"","body":"OSI七层模型 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"network/http.html":{"url":"network/http.html","title":"HTTP","keywords":"","body":"HTTP By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"network/tcp.html":{"url":"network/tcp.html","title":"TCP","keywords":"","body":"TCP By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "},"network/question.html":{"url":"network/question.html","title":"网络中常见的问题","keywords":"","body":"网络中常见的问题 By henrybewell，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2023-04-01 16:52:04 "}}